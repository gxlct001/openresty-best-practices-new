# 操作语义和基本原理

Lua 只使用一个数字类型，并且还支持在编译时重新定义。 默认情况下，这是一个双精度数，即精度为 53 位的浮点数。 在 32 位数字范围内（甚至更高）的操作是精确的。 没有精度损失，因此无需额外增加一个整数类型。 现代台式机和服务器 CPU 均具有快速浮点硬件 —— FP 算术运算的速度几乎与整数算术运算的相同。 在 Lua 解释器本身的开销下，任何差异都将消失。

即使在今天，许多嵌入式系统仍然缺乏对快速 FP 操作的支持。 这些系统受益于用整数类型（32 位或更多）编译 Lua。

在 Lua 数字上定义位运算时，不同的可能数字类型和 FP 数字的使用会导致一些问题。 以下各节定义了操作语义，并试图解释其背后的原理。

## Input and Output Ranges

## 输入和输出范围

- 位运算不能合理地应用于 FP 数字(或其底层位模式)。在对它们进行运算之前，必须将它们转换为整数，然后再转换回 FP 数字。

- 定义在所有平台上都相同的语义是可取的。这说明所有运算都基于 **32 位整数** 的公分母。

- 浮点型仅提供 24 位精度。这使得它不适合在位操作中使用。Lua BitOp 拒绝针对具有此数字类型的 Lua 安装进行编译。

- 位操作只处理底层的位模式，通常忽略符号(算术右移除外)。不过，它们通常被显示为无符号数字，并被当作无符号数字对待。

- 但是 Lua 数字类型必须是有符号的，并且可以限制为 32 位。将结果类型定义为无符号数字不是跨平台安全的。因此，所有位操作都被定义为返回有符号 32 位数字范围内的结果(转换为 Lua 数字类型)。

- 在将十六进制字面量转换为 Lua 数字类型之前，Lua 解析器将其视为无符号数字。这意味着，如果 Lua 数字类型的范围更大，则它们可能超出有符号 32 位整数的范围。例如，0xFFFFFFFF 在默认安装中的值为 4294967295，但在嵌入式系统中可能为 -1。

- 在位操作中使用十六进制字面量时，最好跨系统统一处理。所有位操作都接受有符号或无符号 32 位范围内的参数(更多信息，请参阅下文)。具有相同基础位模式的数字在所有操作中都被相同处理。

## 模运算

对 n 位整数的算术运算通常基于以 2<sup>n</sup> 为模的 [模运算](http://en.wikipedia.org/wiki/Modular_arithmetic) 规则。当运算的数学结果超出其定义范围时，数字将会周期循环。这简化了硬件实现，并且某些算法实际上需要这种行为（比如许多加密函数）。

例如，对于 32 位整数，以下等式成立：0xffffffff + 1 = 0。

如果 Lua 数字类型是 32 位整数，则 **算术模数 2<sup>32</sup>**十分有用。否则，必须插入标准化步骤。模运算应在所有平台上尽可能相同地工作：

- 对于默认的数字类型 double，**参数可以在 ±2<sup>51</sup> 的范围内**，并且仍可以通过采用最低有效 32 位在所有平台上安全地规范化。该限制是从将双精度数转换为整数的方式得出的。
- bit.tobit 函数 **可用于显式规范化数字**，以实现 **模数的加法或减法**。例如，bit.tobit(0xffffffff + 1) 在所有平台上都返回 0。

- 自变量范围的限制意味着，模乘通常仅限于将已经标准化的数字与小常数相乘。无论如何，FP 数字的精度限制为 53 位。例如，(2<sup>30</sup> + 1)<sup>2</sup>用双精度计算时不返回奇数。

顺便说一句：[此处](https://bitop.luajit.org/api.html#shortcuts) 显示的 tr_i 函数是（有缺陷的）MD5 加密哈希的非线性函数之一，它依赖于模运算来实现正确操作。结果将反馈给其他位运算（未显示），直到最后一步才需要进行标准化。

## 受限和未定义的行为

下面的规则旨在给出一个精确而有用的定义(对于程序员来说)，同时给予实现(解释器和编译器)最大的灵活性和应用高级优化的自由。强烈建议不要依赖未定义或实现定义的行为。

- 对于位运算来说各种浮点数都是可接受的。它们都不会导致错误，但是有些可能会引发未定义的行为：

  - -0 在输入上与 +0 相同，因此不会返回。
  - 如果将 **±Inf、NaN 或超出 ±2<sup>51</sup>** 范围的数字作为输入，则会产生 **不确定** 的结果。
  - **非整数** 可以通过 **实现定义**（**implementation-defined**） 的方式四舍五入或截断。这意味着结果可能在不同的 BitOp 版本、不同的 Lua VM、不同平台上，甚至在解释代码与编译代码之间有所不同（例如在 [LuaJIT](http://luajit.org/) 中）。
    避免将小数传递给位操作函数。使用 math.floor() 或 math.ceil() 获取定义的行为。

- 默认情况下，Lua 将字符串参数 **自动强制转换为数字**。对于位操作，此操作 **已弃用**。
